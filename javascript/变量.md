# 变量
js中的数据类型
- null (奇葩)
- undefined (为声明)
- number (数字)
- string (字符串)
- boolean (布尔值)
- object (对象)
- symbol (符号)

## 类型判断

> #### typeof
typeof可以用来判断 number, string, object, boolean, function, undefined, symbol 这七种类型  
但是它并不能具体的告诉我们是哪种object
```javascript
typeof undefined  //"undefined"
typeof 1          //"number"
typeof '1'        //"string"
typeof true       //"boolean"
typeof Symbol()   //symbol
typeof {}         //"object"
```

比较特殊的是null和function
```javascript
typeof null             //"object"
typeof function(){}     //"function"
typeof Array            //"function"
```
这里便涉及typeof的原理问题  
JS在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息，而typeof通过机器码来判断类型 
- 000：对象
- 010：浮点数
- 100：字符串
- 110：布尔 
- 1：整数  
但是对于null来说，null的所有机器码都是0（代表了空指针），故因此也被当作对象 

> ### instanceof
由于typeof不能判断属于哪种object，这个时候就用instanceof来判断是否是某个预期的类型  
在这里null便显出了原型，它并不属于Object，这是历史遗留bug
```javascript
null instanceof Object      //false
```
instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，判断一个实例是否是其父类型或者祖先类型的实例
```javascript
console.log(Object instanceof Object);      //true 
console.log(Function instanceof Function);  //true 
console.log(Number instanceof Number);      //false 
console.log(String instanceof String);      //false 
 
console.log(Function instanceof Object);    //true 
 
console.log(Foo instanceof Function);       //true 
console.log(Foo instanceof Foo);            //false
```
Object 和 Function instanceof 自己等于 true，而其它类instanceof自己却不等。  
这里便涉及instanceof的原理：  

- 语言规范中是如何定义这个运算符的  
- JavaScript 原型继承机制。  

JavaScript instanceof 运算符代码
```javascript
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
 var O = R.prototype;// 取 R 的显示原型
 L = L.__proto__;// 取 L     的隐式原型
 while (true) { 
   if (L === null) 
     return false; 
   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
     return true; 
   L = L.__proto__; 
 } 
}
```
JavaScript 原型继承机制
![](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg)

>### constructor
利用上面的原型继承机制,constructor也可以用来判断是否是某个预期的类型  

```javascript
({}).constructor === Object                 //true
({}).constructor === Array                  //true
(1).constructor === Number                  //true
('2').constructor === String                //true
(false).constructor === Boolean             //true
(function(){}).constructor === Function     //true
(new Date()).constructor === Date           //true
(Symbol()).constructor === Symbol           //true

(null).constructor === Object
(undefined).constructor === undefined
VM1898:1 Uncaught TypeError: Cannot read property 'constructor' of null
null, undefined 没有构造函数
```
> ### Object.prototype.toString
此方法便可以比较精确的判断  变量的类型
```javascript
Object.prototype.toString.call(1)           // "[object Number]"

Object.prototype.toString.call('hi')        // "[object String]"

Object.prototype.toString.call({a:'hi'})    // "[object Object]"

Object.prototype.toString.call([1,'a'])     // "[object Array]"

Object.prototype.toString.call(true)        // "[object Boolean]"

Object.prototype.toString.call(() => {})    // "[object Function]"

Object.prototype.toString.call(new Date())  //"[object Date]"

Object.prototype.toString.call(Symbol(1))   // "[object Symbol]"

Object.prototype.toString.call(null)        // "[object Null]"

Object.prototype.toString.call(undefined)   // "[object Undefined]"
```
