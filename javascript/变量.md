# 变量
[类 型 判 断](#类型判断)  
[类 型 转 换](#类型转换) 

***

js中的数据类型
- null (奇葩)
- undefined (为声明)
- number (数字)
- string (字符串)
- boolean (布尔值)
- object (对象)
- symbol (符号)

## [类型判断](#变量)

> ### typeof
typeof可以用来判断 number, string, object, boolean, function, undefined, symbol 这七种类型  
但是它并不能具体的告诉我们是哪种object
```javascript
typeof undefined  //"undefined"
typeof 1          //"number"
typeof '1'        //"string"
typeof true       //"boolean"
typeof Symbol()   //symbol
typeof {}         //"object"
```

比较特殊的是null和function
```javascript
typeof null             //"object"
typeof function(){}     //"function"
typeof Array            //"function"
```
这里便涉及typeof的原理问题  
JS在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息，而typeof通过机器码来判断类型 
- 000：对象
- 010：浮点数
- 100：字符串
- 110：布尔 
- 1：整数  
但是对于null来说，null的所有机器码都是0（代表了空指针），故因此也被当作对象 

> ### instanceof
由于typeof不能判断属于哪种object，这个时候就用instanceof来判断是否是某个预期的类型  
在这里null便显出了原型，它并不属于Object，这是历史遗留bug
```javascript
null instanceof Object      //false
```
instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，判断一个实例是否是其父类型或者祖先类型的实例
```javascript
console.log(Object instanceof Object);      //true 
console.log(Function instanceof Function);  //true 
console.log(Number instanceof Number);      //false 
console.log(String instanceof String);      //false 
 
console.log(Function instanceof Object);    //true 
 
console.log(Foo instanceof Function);       //true 
console.log(Foo instanceof Foo);            //false
```
Object 和 Function instanceof 自己等于 true，而其它类instanceof自己却不等。  
这里便涉及instanceof的原理：  

- 语言规范中是如何定义这个运算符的  
- JavaScript 原型继承机制。  

JavaScript instanceof 运算符代码
```javascript
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
 var O = R.prototype;// 取 R 的显示原型
 L = L.__proto__;// 取 L 的隐式原型
 while (true) { 
   if (L === null) 
     return false; 
   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
     return true; 
   L = L.__proto__; 
 } 
}
```
JavaScript 原型继承机制  
![](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg)

> ### constructor
利用上面的原型继承机制,constructor也可以用来判断是否是某个预期的类型  

```javascript
({}).constructor === Object                 //true
({}).constructor === Array                  //true
(1).constructor === Number                  //true
('2').constructor === String                //true
(false).constructor === Boolean             //true
(function(){}).constructor === Function     //true
(new Date()).constructor === Date           //true
(Symbol()).constructor === Symbol           //true

(null).constructor === Object
(undefined).constructor === undefined
VM1898:1 Uncaught TypeError: Cannot read property 'constructor' of null
null, undefined 没有构造函数
```
> ### Object.prototype.toString
此方法便可以比较精确的判断  变量的类型
```javascript
Object.prototype.toString.call(1)           // "[object Number]"

Object.prototype.toString.call('hi')        // "[object String]"

Object.prototype.toString.call({a:'hi'})    // "[object Object]"

Object.prototype.toString.call([1,'a'])     // "[object Array]"

Object.prototype.toString.call(true)        // "[object Boolean]"

Object.prototype.toString.call(() => {})    // "[object Function]"

Object.prototype.toString.call(new Date())  //"[object Date]"

Object.prototype.toString.call(Symbol(1))   // "[object Symbol]"

Object.prototype.toString.call(null)        // "[object Null]"

Object.prototype.toString.call(undefined)   // "[object Undefined]"
```

## [类型转换](#变量)
> ### ``valueOf()`` 和 ``toString()``
- valueOf		返回对象对应的原始值  
- toString	返回对象的字符串的表现形式
```javascript
/*
1、数字、字符串、布尔值
  valueOf	数据本身（原始值形式）
  toString	数据转成字符串的形式
2、数组
  valueOf	数据本身（对象形式）
  toString	去掉中括号，外面加个引号（本质为调用数组join(',')后的结果）
3、函数
  valueOf	数据本身（对象形式）
  toString	在数据外面加了个引号
4、对象
  valueOf	数据本身（对象形式）
  toString	"[object Object]" 
*/
```
> ### ``Number()`` 转成数字
所有类型的属性都可以转化为数字格式，规则如下

```javascript
Number()方法
1、调用对象的valueOf方法。如果返回原始类型的值，再使用Number函数，不再进行后续步骤
2、如果valueOf方法返回的还是对象，则调用toString方法
3、如果toString方法返回原始类型的值，则对该值使用Number方法，不再进行后续步骤
4、如果toString方法后返回的是还是对象，就报错（一般不会出现）
```

+ undefined	NaN  
+ null			0  
+ 布尔值		true为1，false为0  
+ 字符串
  - 空字符串，空格字符串转为0
  - 非空字符串，并且内容为纯数字（包含进制与科学表示法）转成对应的数字
  - 其余都是NaN  
+ 数字		原来的数字  
+ 对象  
  - 对象、函数转成NaN
  - 数组 空数组转为0，数组里只有一个数据并且这个数据能转成数字，则转成对应的数字，其它都转成NaN 

> ### ``String()`` 转成字符串

所有类型的属性都可以转化为字符串格式，规则如下

```javascript
String()参数为对象的转换原理
1、调用对象的toString方法。如果返回原始类型的值，再使用String函数，不再进行后续步骤
2、如果toString方法返回的还是对象，再调用对象的valueOf方法
3、如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤
4、如果valueOf方法返回的是还是对象，就报错（一般不会出现）  
```

+ 基本数据类型、null、undefined的结果就是给数据加上引号变成字符串
+ 对象
  - 数组的结果为把所有中括号去掉，外面加个引号
  - 对象的结果为'[object Object]'（除了日期对象）
  - 函数的结果为在函数整体外面加个引号 

> ### ``Boolean()`` 转成布尔值

```javascript
Boolean('')     //false
Boolean(' ')    //true
Boolean('0')    //true
Boolean('a')    //true
Boolean(0)      //true
Boolean(1)      //false
```

+ 非空字符串都为true，空字符串''为false
+ 1为true，0 为false，其他数字格式为true
+ 对象都为true

> ### 隐式类型转换

隐式类型转换出现场景
- 不同类型的数据间运算、比较
- 对非布尔值类型的数据求布尔值
- 条件语句的括号里

>> 隐式类型转数字   
- 数学运算符（+ - * / %），但是加号运算里``不能出现字符串或对象类型数据``
- 一元+-（正负操作符）后的数据
- 某些比较运算符

>> 隐式类型转字符串  
- 有``字符串``的加法运算
- 有``对象``的加法运算
- 某些比较运算符
- 调用alert、document.write方法 
>> 隐式类型转布尔值  
+ 取反运算
  + 1个叹号表示，把这个数据转成布尔值后取它的反值  
  + 2个叹号表示，把这个数据转成布尔值
+ 三目运算符
+ 条件语句的小括号里
+ 逻辑运算符 